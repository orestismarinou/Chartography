<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>Thessalia Cartography â€“ Interactive Map</title>
<meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
<link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
<script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
<style>
  body { margin: 0; padding: 0; font-family: Arial, Helvetica, sans-serif; }
  #map { position: absolute; top: 0; bottom: 0; width: 100%; }
  #styleSelector { position: absolute; top: 10px; left: 10px; z-index: 6; background: white; padding: 6px; border-radius: 4px; box-shadow: 0 1px 4px rgba(0,0,0,0.25); }
  #controls { position: absolute; top: 60px; left: 10px; z-index: 6; background: white; padding: 10px; font-size: 13px; border-radius: 6px; width: 300px; max-height: 80vh; overflow-y: auto; box-shadow: 0 2px 6px rgba(0,0,0,0.25); }
  .layer-controls { margin-top:6px; padding:8px; background:#fafafa; border-radius:4px; display:none; }
  .layer-controls label { display:block; font-size:12px; margin-top:6px; }
  .layer-controls input[type="range"], .layer-controls select { width:100%; margin-top:4px; }
  #legend { position: absolute; top: 10px; right: 10px; z-index: 6; background: white; padding: 18px; font-size: 13px; border-radius: 6px; max-width: 360px; max-height: 85vh; box-shadow: 0 2px 6px rgba(0,0,0,0.25); display: none; resize: both; overflow: auto; min-width: 200px; min-height: 100px; }
  .legend-header { margin-bottom: 16px; padding-bottom: 12px; border-bottom: 2px solid #333; }
  .legend-map-title { font-size: 15px; font-weight: 700; color: #000; margin-bottom: 10px; line-height: 1.4; text-align: center; }
  .legend-author { font-size: 10px; color: #555; line-height: 1.4; text-align: left; }
  .legend-author strong { font-weight: 700; }
  .legend-row { display:flex; align-items:center; margin-bottom:8px; }
  .legend-color { width:20px; height:20px; margin-right:8px; border-radius:3px; flex:none; }
  .legend-line { width:40px; height:14px; margin-right:8px; flex:none; }
  .legend-title { font-weight:700; margin-bottom:8px; display:block; }
  .control-value { font-weight:700; margin-left:6px; color:#333; }
  hr { border: none; border-top: 1px solid #eee; margin:8px 0; }
</style>
</head>
<body>

<div id="styleSelector">
  <select id="basemapSelect">
    <option value="https://basemaps.cartocdn.com/gl/positron-gl-style/style.json">Light</option>
    <option value="https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json" selected>Dark</option>
  </select>
</div>

<div id="controls">
  <strong>Layers</strong><br><br>
  <input type="checkbox" id="popdensToggle"> <strong>Population Density (Choropleth)</strong><br>
  <div class="layer-controls" id="popdensControls">
    <label>Method: <select id="classificationMethod"><option value="equal">Equal interval</option><option value="quantile" selected>Quantiles</option><option value="natural">Natural breaks</option><option value="custom">Custom</option></select></label>
    <label id="numClassesLabel">Classes: <select id="numClasses"><option value="3">3</option><option value="4">4</option><option value="5" selected>5</option><option value="6">6</option><option value="7">7</option></select></label>
    <label>Opacity: <span id="popdensOpacityLabel">60%</span><input type="range" id="popdensOpacity" min="0" max="100" value="60"></label>
  </div>
  <hr>
  <input type="checkbox" id="denscoverToggle"> <strong>Density (Dasymmetric)</strong><br>
  <div class="layer-controls" id="denscoverControls">
    <label>Method: <select id="denscoverClassificationMethod"><option value="equal">Equal interval</option><option value="quantile" selected>Quantiles</option><option value="natural">Natural breaks</option><option value="custom">Custom</option></select></label>
    <label id="denscoverNumClassesLabel">Classes: <select id="denscoverNumClasses"><option value="3">3</option><option value="4">4</option><option value="5" selected>5</option><option value="6">6</option><option value="7">7</option></select></label>
    <label>Opacity: <span id="denscoverOpacityLabel">60%</span><input type="range" id="denscoverOpacity" min="0" max="100" value="60"></label>
  </div>
  <hr>
  <input type="checkbox" id="poipopToggle"> <strong>Population (Symbols)</strong><br>
  <div class="layer-controls" id="poipopControls">
    <label>Max Radius: <span id="maxRadiusLabel">100</span><input type="range" id="maxRadius" min="20" max="200" value="100"></label>
    <label>Opacity: <span id="poipopOpacityLabel">25%</span><input type="range" id="poipopOpacity" min="0" max="100" value="25"></label>
  </div>
  <hr>
  <input type="checkbox" id="contoursToggle"> <strong>Potentials (Isopleths)</strong><br>
  <div class="layer-controls" id="contoursControls">
    <label>Opacity: <span id="contoursOpacityLabel">80%</span><input type="range" id="contoursOpacity" min="0" max="100" value="80"></label>
  </div>
  <hr>
  <input type="checkbox" id="dotsToggle"> <strong>Population (Dots)</strong><br>
  <div class="layer-controls" id="dotsControls">
    <label>Size: <span id="dotSizeLabel">1.9</span><input type="range" id="dotSize" min="0.5" max="6" step="0.1" value="1.9"></label>
    <label>Opacity: <span id="dotsOpacityLabel">100%</span><input type="range" id="dotsOpacity" min="0" max="100" value="100"></label>
  </div>
  <hr>
  <input type="checkbox" id="boundariesToggle"> <strong>Boundaries</strong><br>
  <div class="layer-controls" id="boundariesControls">
    <label>Opacity: <span id="boundariesOpacityLabel">100%</span><input type="range" id="boundariesOpacity" min="0" max="100" value="100"></label>
  </div>
</div>

<div id="legend"></div>
<div id="map"></div>

<script>
const map = new maplibregl.Map({
  container: 'map',
  style: 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json',
  center: [22.45, 39.55], zoom: 8.5 
});

const layerDefinitions = {
  popdens: { sourceId: 'popdens-src', layerId: 'popdens-layer', url: 'dimoi_popdens.geojson', dataField: 'POPDENS' },
  denscover: { sourceId: 'denscover-src', layerId: 'denscover-layer', url: 'dimoi_popdens_cover.geojson', dataField: 'DENS_COVER' },
  poipop: { sourceId: 'poipop-src', layerId: 'poipop-layer', url: 'dimoipoi_pop.geojson', dataField: 'POPMUN', maxValueApprox: 150000 },
  contours: { sourceId: 'contours-src', layerId: 'contours-layer', url: 'kampules_WGS84.geojson' },
  dots: { sourceId: 'dots-src', layerId: 'dots-layer', url: 'koukides_500_WGS84.geojson' },
  boundaries: { sourceId: 'boundaries-src', layerId: 'boundaries-layer', url: 'dimoi_oria_WGS84.geojson' }
};

let popdensData = null;
let denscoverData = null;
const enabledLayers = { popdens: false, denscover: false, poipop: false, contours: false, dots: false, boundaries: false };

const colorSchemes = { 
  3: ['#ffcccc', '#ff6666', '#990000'],
  4: ['#ffcccc', '#ff9999', '#cc0000', '#990000'],
  5: ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000'],
  6: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#cc0000', '#990000'],
  7: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#ff0000', '#cc0000', '#990000']
}; 

const denscoverColorSchemes = { 
  3: ['#ffcccc', '#ff6666', '#990000'],
  4: ['#ffcccc', '#ff9999', '#cc0000', '#990000'],
  5: ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000'],
  6: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#cc0000', '#990000'],
  7: ['#ffcccc', '#ff9999', '#ff6666', '#ff3333', '#ff0000', '#cc0000', '#990000']
};

const customBreaks = [30, 75, 150, 300, 600];
const customColors = ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000', '#660000'];
const denscoverCustomBreaks = [500, 1500, 3500, 6000, 8500];
const denscoverCustomColors = ['#ffcccc', '#ff9999', '#ff6666', '#cc0000', '#990000', '#660000'];

function getBreaks(values, n, method) {
  const sorted = values.filter(v => !isNaN(v)).sort((a,b)=>a-b);
  if (!sorted.length) return [];
  if (method === 'equal') {
    const min=sorted[0], max=sorted[sorted.length-1], step=(max-min)/n, breaks=[];
    for(let i=1;i<n;i++) breaks.push(min+step*i); return breaks.map(b=>Number(b.toFixed(2)));
  }
  if (method === 'quantile') {
    const breaks=[]; for(let i=1;i<n;i++) breaks.push(sorted[Math.floor(sorted.length*i/n)]); return breaks.map(b=>Number(b.toFixed(2)));
  }
  if (method === 'natural') {
    const n_data = sorted.length;
    const mat1 = Array.from({length: n_data+1}, () => Array(n+1).fill(0));
    const mat2 = Array.from({length: n_data+1}, () => Array(n+1).fill(0));
    for (let i=1; i<=n; i++) { mat1[1][i] = 1; mat2[1][i] = 0; for (let j=2; j<=n_data; j++) mat2[j][i] = Infinity; }
    for (let l=2; l<=n_data; l++) {
      let s1=0, s2=0, w=0;
      for (let m=1; m<=l; m++) {
        const i3 = l - m + 1; const val = sorted[i3 - 1]; s2 += val*val; s1 += val; w++;
        const v = s2 - (s1*s1)/w; const i4 = i3 - 1;
        if (i4 !== 0) { for (let j=2; j<=n; j++) { if (mat2[l][j] >= (v + mat2[i4][j-1])) { mat1[l][j] = i3; mat2[l][j] = v + mat2[i4][j-1]; } } }
      }
      mat1[l][1] = 1; mat2[l][1] = mat2[l-1][1] + (sorted[l-1]-sorted[0])*(sorted[l-1]-sorted[0]);
    }
    const breaks = []; let k = n_data;
    for (let j = n; j >= 2; j--) { const id = mat1[k][j] - 1; breaks.push(sorted[id]); k = mat1[k][j] - 1; }
    return breaks.reverse().map(b => Number(b.toFixed(2)));
  }
  return [];
}

function createStepExpr(breaks, colors, field) {
  const expr = ['step', ['get', field], colors[0]];
  for (let i=0; i<breaks.length; i++) { expr.push(breaks[i]); expr.push(colors[i+1]||colors[colors.length-1]); }
  return expr;
}

function ensureSource(id, data) { if(!map.getSource(id)) map.addSource(id, {type:'geojson', data:data}); }

function updatePopDens() {
  if(!popdensData) return;
  const method = document.getElementById('classificationMethod').value;
  const n = parseInt(document.getElementById('numClasses').value);
  let breaks, colors;
  if(method==='custom') { breaks=customBreaks; colors=customColors; }
  else { colors = colorSchemes[n]; breaks = getBreaks(popdensData.features.map(f=>f.properties.POPDENS), n, method); }
  ensureSource(layerDefinitions.popdens.sourceId, popdensData);
  const expr = createStepExpr(breaks, colors, 'POPDENS');
  if(map.getLayer(layerDefinitions.popdens.layerId)) map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-color', expr);
  else map.addLayer({ id:layerDefinitions.popdens.layerId, type:'fill', source:layerDefinitions.popdens.sourceId, paint:{ 'fill-color':expr, 'fill-opacity':parseInt(document.getElementById('popdensOpacity').value)/100 }});
  layerDefinitions.popdens.breaks = breaks; layerDefinitions.popdens.colors = colors;
  enabledLayers.popdens = true; document.getElementById('popdensControls').style.display='block'; updateLegend();
}

function updateDensCover() {
  if(!denscoverData) return;
  const method = document.getElementById('denscoverClassificationMethod').value;
  const n = parseInt(document.getElementById('denscoverNumClasses').value);
  let breaks, colors;
  if(method==='custom') { breaks=denscoverCustomBreaks; colors=denscoverCustomColors; }
  else { colors = denscoverColorSchemes[n]; breaks = getBreaks(denscoverData.features.map(f=>f.properties.DENS_COVER), n, method); }
  ensureSource(layerDefinitions.denscover.sourceId, denscoverData);
  const expr = createStepExpr(breaks, colors, 'DENS_COVER');
  if(map.getLayer(layerDefinitions.denscover.layerId)) map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-color', expr);
  else map.addLayer({ id:layerDefinitions.denscover.layerId, type:'fill', source:layerDefinitions.denscover.sourceId, paint:{ 'fill-color':expr, 'fill-opacity':parseInt(document.getElementById('denscoverOpacity').value)/100 }});
  layerDefinitions.denscover.breaks = breaks; layerDefinitions.denscover.colors = colors;
  enabledLayers.denscover = true; document.getElementById('denscoverControls').style.display='block'; updateLegend();
}

function loadPopDens() { fetch(layerDefinitions.popdens.url).then(r=>r.json()).then(gj=>{ popdensData=gj; updatePopDens(); }).catch(e=>console.error(e)); }
function loadDensCover() { fetch(layerDefinitions.denscover.url).then(r=>r.json()).then(gj=>{ denscoverData=gj; updateDensCover(); }).catch(e=>console.error(e)); }
function loadPoiPop() {
  fetch(layerDefinitions.poipop.url).then(r=>r.json()).then(gj=>{
    gj.features.sort((a,b)=> (b.properties.POPMUN||0)-(a.properties.POPMUN||0));
    ensureSource(layerDefinitions.poipop.sourceId, gj);
    const radiusExpr = ['*', ['^', ['/', ['get', 'POPMUN'], 150000], 0.57], parseInt(document.getElementById('maxRadius').value)];
    if(!map.getLayer(layerDefinitions.poipop.layerId)) map.addLayer({id:layerDefinitions.poipop.layerId, type:'circle', source:layerDefinitions.poipop.sourceId, paint:{'circle-color':'rgba(255,0,0,0.25)', 'circle-stroke-color':'red', 'circle-stroke-width':1, 'circle-radius':radiusExpr, 'circle-opacity': parseInt(document.getElementById('poipopOpacity').value)/100 }});
    else map.setPaintProperty(layerDefinitions.poipop.layerId, 'circle-radius', radiusExpr);
    enabledLayers.poipop=true; document.getElementById('poipopControls').style.display='block'; updateLegend();
  });
}

function loadContours() {
  ensureSource(layerDefinitions.contours.sourceId, layerDefinitions.contours.url);
  if(!map.getLayer(layerDefinitions.contours.layerId)) map.addLayer({id:layerDefinitions.contours.layerId, type:'line', source:layerDefinitions.contours.sourceId, paint:{'line-color':'#8B0000', 'line-width':2, 'line-opacity': parseInt(document.getElementById('contoursOpacity').value)/100 }});
  enabledLayers.contours=true; document.getElementById('contoursControls').style.display='block'; updateLegend();
}

function loadDots() {
  ensureSource(layerDefinitions.dots.sourceId, layerDefinitions.dots.url);
  if(!map.getLayer(layerDefinitions.dots.layerId)) map.addLayer({id:layerDefinitions.dots.layerId, type:'circle', source:layerDefinitions.dots.sourceId, paint:{'circle-color':'red', 'circle-radius':parseFloat(document.getElementById('dotSize').value), 'circle-opacity': parseInt(document.getElementById('dotsOpacity').value)/100 }});
  enabledLayers.dots=true; document.getElementById('dotsControls').style.display='block'; updateLegend();
}

function loadBoundaries() {
  ensureSource(layerDefinitions.boundaries.sourceId, layerDefinitions.boundaries.url);
  if(!map.getLayer(layerDefinitions.boundaries.layerId)) map.addLayer({id:layerDefinitions.boundaries.layerId, type:'line', source:layerDefinitions.boundaries.sourceId, paint:{'line-color':'#bbbbbb', 'line-width':1, 'line-opacity': parseInt(document.getElementById('boundariesOpacity').value)/100 }});
  enabledLayers.boundaries=true; document.getElementById('boundariesControls').style.display='block'; updateLegend();
}

function removeLayer(key) { 
  if(map.getLayer(layerDefinitions[key].layerId)) map.removeLayer(layerDefinitions[key].layerId); 
  if(map.getSource(layerDefinitions[key].sourceId)) map.removeSource(layerDefinitions[key].sourceId); 
  enabledLayers[key]=false; document.getElementById(key+'Controls').style.display='none'; updateLegend(); 
}

document.getElementById('popdensToggle').addEventListener('change', e=>{ if(e.target.checked) loadPopDens(); else removeLayer('popdens'); });
document.getElementById('denscoverToggle').addEventListener('change', e=>{ if(e.target.checked) loadDensCover(); else removeLayer('denscover'); });
document.getElementById('poipopToggle').addEventListener('change', e=>{ if(e.target.checked) loadPoiPop(); else removeLayer('poipop'); });
document.getElementById('contoursToggle').addEventListener('change', e=>{ if(e.target.checked) loadContours(); else removeLayer('contours'); });
document.getElementById('dotsToggle').addEventListener('change', e=>{ if(e.target.checked) loadDots(); else removeLayer('dots'); });
document.getElementById('boundariesToggle').addEventListener('change', e=>{ if(e.target.checked) loadBoundaries(); else removeLayer('boundaries'); });

document.getElementById('classificationMethod').addEventListener('change', updatePopDens);
document.getElementById('numClasses').addEventListener('change', updatePopDens);
document.getElementById('popdensOpacity').addEventListener('input', e=>{
  document.getElementById('popdensOpacityLabel').innerText = e.target.value + '%';
  if(map.getLayer(layerDefinitions.popdens.layerId)) map.setPaintProperty(layerDefinitions.popdens.layerId, 'fill-opacity', parseInt(e.target.value)/100);
});

document.getElementById('denscoverClassificationMethod').addEventListener('change', updateDensCover);
document.getElementById('denscoverNumClasses').addEventListener('change', updateDensCover);
document.getElementById('denscoverOpacity').addEventListener('input', e=>{
  document.getElementById('denscoverOpacityLabel').innerText = e.target.value + '%';
  if(map.getLayer(layerDefinitions.denscover.layerId)) map.setPaintProperty(layerDefinitions.denscover.layerId, 'fill-opacity', parseInt(e.target.value)/100);
});

document.getElementById('maxRadius').addEventListener('input', e=>{
  document.getElementById('maxRadiusLabel').innerText = e.target.value;
  if(map.getLayer(layerDefinitions.poipop.layerId)) map.setPaintProperty(layerDefinitions.poipop.layerId, 'circle-radius', ['*', ['^', ['/', ['get', 'POPMUN'], 150000], 0.57], parseInt(e.target.value)]);
});
document.getElementById('poipopOpacity').addEventListener('input', e=>{
  document.getElementById('poipopOpacityLabel').innerText = e.target.value + '%';
  if(map.getLayer(layerDefinitions.poipop.layerId)) map.setPaintProperty(layerDefinitions.poipop.layerId, 'circle-opacity', parseInt(e.target.value)/100);
});

document.getElementById('contoursOpacity').addEventListener('input', e=>{
  document.getElementById('contoursOpacityLabel').innerText = e.target.value + '%';
  if(map.getLayer(layerDefinitions.contours.layerId)) map.setPaintProperty(layerDefinitions.contours.layerId, 'line-opacity', parseInt(e.target.value)/100);
});

document.getElementById('dotSize').addEventListener('input', e=>{
  document.getElementById('dotSizeLabel').innerText = e.target.value;
  if(map.getLayer(layerDefinitions.dots.layerId)) map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-radius', parseFloat(e.target.value));
});
document.getElementById('dotsOpacity').addEventListener('input', e=>{
  document.getElementById('dotsOpacityLabel').innerText = e.target.value + '%';
  if(map.getLayer(layerDefinitions.dots.layerId)) map.setPaintProperty(layerDefinitions.dots.layerId, 'circle-opacity', parseInt(e.target.value)/100);
});

document.getElementById('boundariesOpacity').addEventListener('input', e=>{
  document.getElementById('boundariesOpacityLabel').innerText = e.target.value + '%';
  if(map.getLayer(layerDefinitions.boundaries.layerId)) map.setPaintProperty(layerDefinitions.boundaries.layerId, 'line-opacity', parseInt(e.target.value)/100);
});

document.getElementById('basemapSelect').addEventListener('change', e=>{
  map.setStyle(e.target.value);
  map.once('style.load', () => {
    if(enabledLayers.popdens) updatePopDens();
    if(enabledLayers.denscover) updateDensCover();
    if(enabledLayers.poipop) loadPoiPop();
    if(enabledLayers.contours) loadContours();
    if(enabledLayers.dots) loadDots();
    if(enabledLayers.boundaries) loadBoundaries();
  });
});

function updateLegend() {
  const legend = document.getElementById('legend');
  let html = `<div class="legend-header"><div class="legend-map-title">THESSALIA MAP</div><div class="legend-author">Produced by: Orestis Marinou<br>Student ID: rs19004</div></div>`;
  if(enabledLayers.popdens && layerDefinitions.popdens.breaks) {
    html += `<b>Population Density</b><br>`;
    const b = layerDefinitions.popdens.breaks, c = layerDefinitions.popdens.colors;
    html += `<div class="legend-row"><div class="legend-color" style="background:${c[0]}"></div> < ${b[0]}</div>`;
    for(let i=0; i<b.length-1; i++) html += `<div class="legend-row"><div class="legend-color" style="background:${c[i+1]}"></div> ${b[i]} - ${b[i+1]}</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${c[c.length-1]}"></div> > ${b[b.length-1]}</div><hr>`;
  }
  if(enabledLayers.denscover && layerDefinitions.denscover.breaks) {
    html += `<b>Dasymmetric Density</b><br>`;
    const b = layerDefinitions.denscover.breaks, c = layerDefinitions.denscover.colors;
    html += `<div class="legend-row"><div class="legend-color" style="background:${c[0]}"></div> < ${b[0]}</div>`;
    for(let i=0; i<b.length-1; i++) html += `<div class="legend-row"><div class="legend-color" style="background:${c[i+1]}"></div> ${b[i]} - ${b[i+1]}</div>`;
    html += `<div class="legend-row"><div class="legend-color" style="background:${c[c.length-1]}"></div> > ${b[b.length-1]}</div><hr>`;
  }
  if(enabledLayers.poipop) html += `<b>Population</b><br>Circles proportional to pop.<hr>`;
  if(enabledLayers.contours) html += `<b>Potentials</b><br>Red lines<hr>`;
  if(enabledLayers.dots) html += `<b>Density</b><br>Red dots<hr>`;
  legend.innerHTML = html;
  legend.style.display = Object.values(enabledLayers).some(Boolean) ? 'block' : 'none';
}

map.on('load', () => console.log('Map loaded'));
</script>
</body>
</html>
